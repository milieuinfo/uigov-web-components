import {Meta} from '@storybook/addon-docs';
import autocompletePng from '../../resources/afnemen/autocomplete.png';

<Meta title="Afnemen/Cookbook"/>

# Cookbook (WIP)

## Inhoudstafel

- [Artifacts](#artifacts)
- [Styling](#styling)
- [Map](#map)


## Artifacts

### Beschikbaarheid

Alle artifacts zijn beschikbaar via de [JFrog Artifactory](https://repo.omgeving.vlaanderen.be/ui/packages) van
Departement Omgeving. Om ze af te nemen dien je je `~/.npmrc` als volgt te configureren:

```
registry=https://repo.omgeving.vlaanderen.be/artifactory/api/npm/acd-npm/
//repo.omgeving.vlaanderen.be/artifactory/api/npm/acd-npm/:_authToken=xXxyYyzZz
```

Je persoonlijk authToken kan je vinden door naar [JFrog Artifactory](https://repo.omgeving.vlaanderen.be/ui/packages)
te gaan, dan rechtsboven een `Log in` doen, links via `Artifacts` de repo `acd-npm` selecteren en dan via `Set Me Up`
kan je een __token__ genereren.

> ** Opmerking**: als je (tijdelijk) wil wisselen naar de 'default' npm repository kan je in je `~/.npmrc` bestand de
registry lijn in commentaar zetten en vervangen door `registry=https://registry.npmjs.org/`

<br />

### Typing - .d.ts files

De broncode van de uigov-web-components wordt in TypeScript geschreven. In de npm packages wordt die code naar
JavaScript getranspilede, daarnaast zitten er ook .d.ts bestanden in de bundel. Door eindtoepassingen in TypeScript te
schrijven zorgen deze .d.ts bestanden ervoor dat je typed kan werken en er bvb. autocomplete functionaliteit in
je IDE is.

<img src={autocompletePng} alt="Autocomplete" height="350px"/>
<br />


### Debugging - map files

In de npm packages van de uigov-web-components zitten ook .js.map bestanden. De .js bestanden hebben een referentie
naar die .js.map bestanden waarin de originele broncode (in TypeScript) zit. Als de configuratie juist is kan je
daarmee de broncode van de uigov-web-components debuggen.

Als je je eindtoepassing bundelt met [webpack](https://webpack.js.org/) dien je in je webpack configuratie de
[source-map-loader](https://webpack.js.org/loaders/source-map-loader/) toe te voegen. Deze plugin zorgt ervoor dat
de .js.map bestanden transitief mee opgenomen worden in de bundel van de eindtoepassing.

Om de plugin te gebruiken moet je hem installeren
```
npm i -D source-map-loader
```

en nadien configureren
```
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        enforce: "pre",
        use: ["source-map-loader"],
      },
    ],
  },
};
```


### FatJs

TODO - Kris S.


## Imports

### Import Varianten

Er zijn verschillende manieren om te [importeren](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).
De meest gangbare om de @domg-wc web-componenten te gebruiken zijn:

#### Import met side-effects

```
import '@domg-wc/elements/button';
```

Voor elke component is er op component niveau een barrel file voorzien (index.js). Indien er meerdere (sub-)componenten
zijn worden deze allemaal door deze import geregistreerd, in dit geval `VlButtonElement` en `VlLinkButtonElement`.
Op deze manier krijg je __geen referentie__ naar de component, maar zowel de IDE als de bundler (bvb. webpack) weerhoudt
de code (ze wordt niet verwijderd omdat ze als dode code gezien wordt).

#### Named Import

```
import { registerWebComponents } from '@domg-wc/common-utilities';
import { VlButtonElement, VlLinkButtonElement } from '@domg-wc/elements/button';

registerWebComponents([VlButtonElement, VlLinkButtonElement]);
```

Bij een named import moet je ook 'iets' doen met de referentie, anders zal zowel de IDE als de bundler dit als 'dode'
code zien. Je IDE zal bij een re-arrange de import verwijderen, de bundler zal de code __niet weerhouden__.
Om dit te vermijden moet je de referentie gebruiken. Het is voldoende de referentie op te nemen, gewoon `VlButtonElement;`
onder je import zetten. Om echter duidelijk te maken waarom je dit doet voorzien we de methode `registerWebComponents`.

#### Named Import via root-barrel file

```
import { registerWebComponents } from '@domg-wc/common-utilities';
import { VlButtonElement, VlLinkButtonElement } from '@domg-wc/elements';

registerWebComponents([VlButtonElement, VlLinkButtonElement]);
```

Dit is een variant op de gewone named import. Elke @domg-wc artifact voorziet op root niveau een barrel file waarin alle
componenten van het artifact ge-exporteerd worden. <br/>
Belangrijk: in de package.json van het artifact wordt de root-barrel-file expliciet gemarkeerd als
__zonder neveneffecten__. Dit maakt dat je op deze manier enkel de componenten die je refereert importeert, niets meer.

### Side Effects

Een [JavaScript side effect](https://sgom.es/posts/2020-06-15-everything-you-never-wanted-to-know-about-side-effects/)
is code die uitgevoerd wordt omdat ze geïmporteerd wordt, niet omdat ze aangeroepen wordt. Dit heeft impact op het
tree-shaken bij het bundelen. Vaak gebeurd het registreren van een web-component als side-effect in dezelfde module
(bestand) als waar de component gedefinieerd wordt.

Opmerking: de `@domg-wc` web-componenten worden geregistreerd m.b.v. de
[decorator](https://netbasal.com/behind-the-scenes-how-typescript-decorators-operate-28f8dcacb224) `@webComponent`
die zorgt ervoor dat na typescript transpilatie de javascript code er als onderstaand uitziet. Daardoor zal de
registratie gebeuren onafhanklijk van de manier van importeren, zolang de code maar niet ge-tree-shaked wordt!

```
let VlAccordionComponent = class VlAccordionComponent extends BaseElementOfType(HTMLElement) {
 ...
};
VlAccordionComponent = __decorate([
    webComponent('vl-accordion'),
    __metadata("design:paramtypes", [])
], VlAccordionComponent);
export { VlAccordionComponent };
```


## Tree Shaking

Als je een bundler gebruikt - bvb. webpack of rollup - dan zal deze transitief (typisch vertrekkend vanuit je
applicatieve index.js) enkel die code opnemen die je importeert. Code die niet gerefereerd wordt of als ongebruikt
gezien wordt beland niet in de bundel. Dit proces van enkel relevante code opnemen noemt
[tree shaking](https://webpack.js.org/guides/tree-shaking/).

De te preferen bundler bij Departement Omgeving is webpack. Om te tree-shaken houdt webpack rekening met de
['sideEffects'](https://webpack.js.org/guides/tree-shaking/#clarifying-tree-shaking-and-sideeffects) zoals
gespecifieerd in de package.json's (zowel van de applicatie als van de bibliotheken die gerefereerd worden).
Belangrijk hierbij is dat de default (indien er niets gespecifieerd wordt) `sideEffects=true` is. Dit heeft tot
gevolg dat als je eender welke named import doet via een barrel file ook alle andere vermelde exports geïmporteerd
worden. Om die rede worden in de `@domg-wc` artifacts de root-barrel files ge-exclude uit de sideEffects. Vroeger
(<v1.17.0) werd de default gebruikt waardoor er niet ge-tree-shaked werd als je op die manier imports deed en via
webpack de bundel maakte.

Opmerking 1: webpack werkt eigenlijk niet conform de import specificatie, een named import zou eigenlijk geen
side-effects mogen geven, daarvoor is expliciet de 'import with side-effects' voorzien.

Opmerking 2: omdat we __op component niveau__ - voor webpack - sideffects activeren voor die sub-barrel files zorgt
dat ervoor dat als je het onderstaande doet toch ook `VlLinkButtonElement` geregistreerd wordt. Terwijl als je via de
root-barrel file gaat VlLinkButtonElement niet geregistreerd wordt!

```
import { VlButtonElement } from '@domg-wc/elements/button';
VlButtonElement;
```


## Styling

### Elementen & CSS

Alle `@domg-wc elementen`, zijnde de web-componenten die zich in de package `@domg-wc/elements` bevinden, zorgen
ervoor dat eenmalig alle css op document niveau geregistreerd wordt. Technisch gebeurd dat door de decorator
`@elementStyles` die de volgende code uitvoert:

```
class RegisterStyles {
    static elementStylesRegistered = false;

    static registerElementsStyles() {
        if (!RegisterStyles.elementStylesRegistered) {
            document.adoptedStyleSheets = [
                ...document.adoptedStyleSheets,
                ...(allElementStyles.map((style) => style.styleSheet) as CSSStyleSheet[]),
            ];
            RegisterStyles.elementStylesRegistered = true;
            console.log('alle element styling toegevoegd aan de document style-sheets');
        }
    }
}
```


### Custom CSS

Voor de componenten onder `map` en `components` is het mogelijk om een custom CSS-string mee te geven aan het
attribuut `data-vl-custom-css`. Deze CSS wordt dan toegevoegd aan de adoptedStyleSheets van de shadow DOM van
de desbetreffende component.

> Opgelet bij het gebruik hiervan, hierdoor kan je de styling van DV breken!

```html
<vl-accordion-list data-vl-custom-css=".vl-accordion-list {border: 10px solid lightblue}">
```

### 4 background css classes

TODO - Kris S.


### kleuren palet

TODO - na implementatie van https://www.milieuinfo.be/jira/browse/UIG-2514


## Map

### Open Layers

TODO - referentie(s) - Karim D.
