import {Meta} from '@storybook/addon-docs';

<Meta title="Recepten/Imports"/>

# Imports

## Import Varianten

Er zijn verschillende manieren om te [importeren](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).
De meest gangbare om de @domg-wc web-componenten te gebruiken zijn:

### Import met side-effects

```
import '@domg-wc/elements/button';
```

Voor elke component is er op component niveau een barrel file voorzien (index.js). Indien er meerdere (sub-)componenten
zijn worden deze allemaal door deze import geregistreerd, in dit geval `VlButtonElement` en `VlLinkButtonElement`.
Op deze manier krijg je __geen referentie__ naar de component, maar zowel de IDE als de bundler (bvb. webpack) weerhoudt
de code (ze wordt niet verwijderd omdat ze als dode code gezien wordt).

### Named Import

```
import { registerWebComponents } from '@domg-wc/common-utilities';
import { VlButtonElement, VlLinkButtonElement } from '@domg-wc/elements/button';

registerWebComponents([VlButtonElement, VlLinkButtonElement]);
```

Bij een named import moet je ook 'iets' doen met de referentie, anders zal zowel de IDE als de bundler dit als 'dode'
code zien. Je IDE zal bij een re-arrange de import verwijderen, de bundler zal de code __niet weerhouden__.
Om dit te vermijden moet je de referentie gebruiken. Het is voldoende de referentie op te nemen, gewoon `VlButtonElement;`
onder je import zetten. Om echter duidelijk te maken waarom je dit doet voorzien we de methode `registerWebComponents`.

### Named Import via root-barrel file

```
import { registerWebComponents } from '@domg-wc/common-utilities';
import { VlButtonElement, VlLinkButtonElement } from '@domg-wc/elements';

registerWebComponents([VlButtonElement, VlLinkButtonElement]);
```

Dit is een variant op de gewone named import. Elke @domg-wc artifact voorziet op root niveau een barrel file waarin alle
componenten van het artifact ge-exporteerd worden. <br/>
Belangrijk: in de package.json van het artifact wordt de root-barrel-file expliciet gemarkeerd als
__zonder neveneffecten__. Dit maakt dat je op deze manier enkel de componenten die je refereert importeert, niets meer.

## Side Effects

Een [JavaScript side effect](https://sgom.es/posts/2020-06-15-everything-you-never-wanted-to-know-about-side-effects/)
is code die uitgevoerd wordt omdat ze ge√Ømporteerd wordt, niet omdat ze aangeroepen wordt. Dit heeft impact op het
tree-shaken bij het bundelen. Vaak gebeurd het registreren van een web-component als side-effect in dezelfde module
(bestand) als waar de component gedefinieerd wordt.

Opmerking: de `@domg-wc` web-componenten worden geregistreerd m.b.v. de
[decorator](https://netbasal.com/behind-the-scenes-how-typescript-decorators-operate-28f8dcacb224) `@webComponent`
die zorgt ervoor dat na typescript transpilatie de javascript code er als onderstaand uitziet. Daardoor zal de
registratie gebeuren onafhanklijk van de manier van importeren, zolang de code maar niet
[ge-tree-shaked](/docs/recepten-tree-shaking--documentatie) wordt!

```
let VlAccordionComponent = class VlAccordionComponent extends BaseElementOfType(HTMLElement) {
 ...
};
VlAccordionComponent = __decorate([
    webComponent('vl-accordion'),
    __metadata("design:paramtypes", [])
], VlAccordionComponent);
export { VlAccordionComponent };
```
