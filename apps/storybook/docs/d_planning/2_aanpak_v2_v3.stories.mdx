import {Meta} from '@storybook/blocks';

<Meta title="Planning/Aanpak v2 [2024] & v3 [2025]"/>

# Aanpak v2 & v3

## Inhoudstafel

- [Waarom v2](#waarom-v2)
- [Waarom Next Componenten](#waarom-next-componenten)
- [Next Conventies](#next-conventies)
- [v2 vs. v3](#v2-vs-v3)
- [v2 Release](#v2-release)


## Waarom v2

De basis van de code die er is [dateert](/docs/historiek-toekomst--documentatie) van 2020. Er is toen vertrokken
vanuit het idee de code van [Webuniversum v3](https://overheid.vlaanderen.be/webuniversum/v3/) as-is af te nemen.
Dit had een aantal gevolgen:

### Element complicatie

Componenten zoals de DV [vl-ui-button](https://overheid.vlaanderen.be/webuniversum/v3/documentation/atoms/vl-ui-button)
moeten als een uitbreiding op een native button ge誰mplementeerd worden. De UIG web component moet dus extenden van
HTMLButtonElement. De rede is dat de scss van DV enkel werkt op een `button` tag, een custom component maken met als
tag `vl-button` werkt niet (de css die DV voorziet is daarvoor niet correct). Er was wel de mogelijkheid geweest om de
component te schrijven als wrapper: een `vl-button` die dan daarin een `button` rendert, maar die keuze is toen niet
gemaakt.

Die keuze, om dus de vl-button als een uitbreiding op een button te implementeren, heeft een aantal gevolgen:

- afnemers moeten dit type componenten op een specifieke manier gebruiken: m.b.v. het `is=` attribuut, zie
  [https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is)
- Safari gaat dit nooit ondersteunen, we moeten de polyfill `@ungap/custom-elements` voorzien om dat in Safari te
  ondersteunen
- bestaande web component frameworks: bvb. [Lit](https://lit.dev/) en [Stencil](https://stenciljs.com/docs/introduction)
  ondersteunen het niet; overal LitElement (om consistent te zijn) als basis klasse gebruiken kan dus niet
- omdat op die manier - aan native elementen - extra attributen toegevoegd worden door de implementatie, en om
  tegelijkertijd aan de HTML5 standaard te voldoen, is er gekozen de nieuwe attributen te prefixen met 'data-'; dit is
  dan (om consistentie redenen) bij alle componenten zo doorgevoerd - terwijl dat voor componenten met een custom-tag
  geen verplichting (en eigenlijk niet de bedoeling) is

Opmerking: om duidelijk te maken of een bepaalde component gebruikt moet worden via een `custom tag` of via het `is=`
attribuut zijn in de nieuwe `@domg-wc` componenten (v1.x.x) alle componenten, die als uitbreiding op een native tag
ge誰mplementeerd zijn, gegroepeerd in het `@domg-wc/elements` artifact.


### JavaScript complicatie

Een aantal DV componenten bevatten JavaScript. Die is deels door DV zelf geschreven en deels afkomstig van andere
bibliotheken. De DV specifieke JavaScript voorziet een soort van lifecycle waarbij componenten 'ge-dressed' worden.
Doordat er soms 'patches' dienden te gebeuren (en vermoedelijk om consistent te zijn) is uiteindelijk de meeste van
die JavaScript in onze code-base als code beland, dus niet als dependency naar DV- of externe artifacts. Dit heeft
volgende gevolgen:

- upgrades zijn moeilijk, doordat 'onze' JavaScript afwijkt van deze van DV kunnen we niet zomaar de meest recente
  versie binnentrekken - we zouden deze moeten diffen, copy-pasten en aanpassen
- er zijn rechten issues: omdat die JavaScript code een mix is van DV- en externe code weten we de bron en
  de versie niet, we kunnen dus niet controleren of de licentie van die code wel toestaat dat we ze overnemen
- de eigen DV-lifecycle is niet eenduidig en dus moeilijk correct te laten samen werken met de
  [web components lifecycle](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#custom_element_lifecycle_callbacks)
  of de [Lit lifecycle](https://lit.dev/docs/components/lifecycle/)


### SCSS complicatie

DV voorziet alle css is scss formaat, hierdoor kunnen ze gestructureerde css schrijven met mixins, variabelen,
nesting, ... . Dit heeft wel gevolgen bij ons:

- wij moeten die scss omzetten naar css, ofwel door een plugin in de build (wat we vroeger deden) ofwel door zelf een
  pre-process'de bibliotheek te voorzien (wat we tegenwoordig doen via `@domg/govflanders-style`)
- scss is geen 'standaard', wat toch 1 van de basis principes is van de keuzes gemaakt in 2020
- Lit - wat we als uniforme basis nemen - ondersteunt geen scss
- de fragmentatie door DV van de scss is niet goed om web componenten te schrijven: bij normaal gebruik wordt alle scss
  nodig voor een website op 1 plaats ge誰mporteerd, op die manier krijg je minimale duplicatie.
  Web componenten zijn echter self contained, elke component bevat alles wat hij nodig heeft, het gevolg is dat we
  in elke component alle 'gedeelde' css krijgen, daarin zit vaak overbodige css (voor die component)
  en over componenten heen is er nodeloze duplicatie.


## Waarom 'Next' Componenten

Om de componenten af te nemen, maar ook om ze te implementeren, is eenduidigheid belangrijk. We proberen de
UIG-componenten zo backwards compatibel als mogelijk te laten evolueren. Echter, om alles eenduidig te maken,
zullen we backwards incompatibele wijzigingen moeten doorvoeren.

Op zich zouden we dat kunnen doen door een fork te maken van de huidige code en in die fork aan een v2 release te
werken. Op die manier werken leek ons niet realistisch:

- voor de componenten die niet (of beperkt) wijzigen moeten bugfixes en features op 2 plaatsen gebeuren
- als we componenten maar in v2 opnemen als ze volledig klaar zijn gaat het jaren duren voor alle componenten
  (inclusief de map) er in zitten
- we gaan niet kunnen (en niet willen) garanderen dat v2 en v1 componenten volledig samenwerken, afnemers gaan dus
  moeten kiezen, maar niemand zal v2 willen / kunnen afnemen zolang die versie niet de bulk van de componenten bevat

Vandaar hebben we er dus voor gekozen om 'next'-componenten te introduceren. We laten de huidige versie van een
component bestaan en verder evolueren. Een nieuwe versie implementeren we in de huidige codebase en geven we
een nieuwe tag door deze te suffixen met '-next'.

**opmerking 1:** We hebben bekeken of we dezelfde tag zouden kunnen gebruiken voor de oude en de nieuwe component,
dan zou het afhangen van de import welke component je gebruikt.
Doordat je een tag maar 1 maal kan registreren (het is dus de oude of de nieuwe component) en er componenten zijn
die zelf andere componenten importeren (en dus registreren) zou je at-runtime overal, fundamenteel, voor de ene of
de andere moeten kiezen. Dit zou onze code, maar ook afnemers hun code veel te hard impacteren (vooral in de
overgangsfase).

**opmerking 2:** We hebben ook bekeken of we
[scoped elements](https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Scoped-Custom-Element-Registries.md)
konden gebruiken, zodat we dezelfde tag konden behouden voor de nieuwe en de oude versie. Dit is echter een voorstel
met een [polyfill prototype](https://www.npmjs.com/package/@webcomponents/scoped-custom-element-registry) implementatie.
Deze oplossing ging technisch complex zijn voor de afnemers en gaf ook moeilijkheden met onze globale css (ook daar
heb je een oude en een nieuwe versie van).


## 'Next' Conventies

Volgende keuzes zijn gemaakt om door te voeren in de 'next'-componenten. Hierdoor wijken ze momenteel af van de andere
componenten. Bij de feitelijke v2 release zullen we de andere componenten in lijn brengen (ook bij deze de next
conventies doorvoeren).

- een component heeft een custom tag die begint met 'vl-' (*)
- een component extend altijd van LitElement (en heeft daardoor de Lit-lifecycle)
- css wordt geschreven als css-in-ts en aangeboden als css-in-js; we voorzien mixins als JavaScript methodes en
  gebruiken standaard css variabelen
- styling wordt aangeboden als css, pure styling wordt niet meer als element of component aangeboden maar gewoon als
  css die je via het `class=` attribuut moet gebruiken (**)
- het 'element' concept verdwijnt, componenten die een native element extenden (dus met het `is=` attribuut gebruikt
  moeten worden) worden stelselmatig weggewerkt:
    * het element wordt in de next-variant een component
    * als het element in een form gebruikt werd komt de next-variant in de form artifact
    * het element wordt een css klasse
    * het element wordt geschrapt
- de `data-` prefix bij de attributen verdwijnt omdat er geen nood meer aan is


## v2 vs. v3

In v2 zullen er nog:

- componenten zijn die extenden van BaseElementOfType
- is de map nog niet volledig conform de nieuwe conventies
- is er nog legacy code (in de common-legacy package)

In versie 3 zal de volledige codebase consistent zijn en wordt alle legacy code geschrapt (common-legacy wordt
verwijderd).


## v2 Release

Zolang we in v1 zitten komen er nieuwe 'next' componenten bij (zie
[[2024] van v1 naar v2 -beschikbaar](/docs/planning-2024-van-v1-naar-v2-beschikbaar--documentatie)), reeds
ge誰mplementeerde 'next' componenten kunnen nog wijzigen daar ze niet finaal zijn. De bestaande componenten blijven
zoals ze geschreven zijn, hun API wijzigt niet.

Bij de v2 release doen we het volgende:

- als er een oude en een nieuwe variant is van dezelfde component wordt de oude geschrapt en bij de nieuwe wordt
  de `-next` suffix verwijderd - de nieuwe vervangt dus de oude; hierdoor is de component niet backwards
  compatibel
- bij de componenten die behouden blijven schrappen we de `data-` prefix, zodat er in v2 nergens nog attributen zijn
  die die conventie volgen

**opmerking 1**: alle componenten die in release v2 zitten zullen ook in de laatste v1 release zitten, er zullen
er echter minder in v2 zitten (de oude worden geschrapt) en ze zullen anders gebruikt moeten worden - de `button`
bvb. moet je niet meer gebruiken m.b.v. `is="vl-button"` maar met de `vl-button` tag

**opmerking 2**: in v2.0.0 zitten geen next-componenten meer, maar vanaf v2.1.0 kunnen er nieuwe next-componenten
komen, deze volgen dan dezelfde conventie: in v3 zullen deze de oude v2 versie vervangen - het doel is wel om dit te
beperken tot de 'map' componenten
